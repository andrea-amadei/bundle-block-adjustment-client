import { PayloadAction } from '@reduxjs/toolkit';import {  ImagesLinkedPoint,  PointOnImage,  Point,  RealPoint,  CameraPosition,} from './interfaces';interface PointMap<T extends Point> {  [id: number]: T;}export function getIdForNewPoint<T extends Point>(state: PointMap<T>) {  return Object.keys(state)    .map(idStr => parseInt(idStr))    .filter(id => !Number.isNaN(id))    .sort( (a,b) => b - a)[0] + 1;}export function addPointBase<T extends Point>(  state: PointMap<T>,  point: T) {  const { pointId } = point;  if (pointId in state) throw Error('Point ID must be unique');  state[pointId] = point;}export function addPointCommon<T extends Point>(  state: PointMap<T>,  action: PayloadAction<T>) {  addPointBase(state, action.payload);}export function removePointCommon<T extends Point>(  state: PointMap<T>,  action: PayloadAction<number>) {  delete state[action.payload];}function getPointOrThrow<T extends Point>(state: PointMap<T>, pointId: number) {  if (!(pointId in state))    throw Error('No existing point with given ID');  return state[pointId];}export function addLinkedPointCommon<  T extends ImagesLinkedPoint<P>,  P extends PointOnImage>(state: PointMap<T>, action: PayloadAction<P>) {  const image = action.payload;  const { pointId, imageId } = image;  const point = getPointOrThrow(state, pointId);  if (imageId in point.linkedImages)    throw Error('Image ID must be unique');  point.linkedImages[imageId] = image;}function getPointAndImageOrThrow<  T extends ImagesLinkedPoint<P>,  P extends PointOnImage>(  state: PointMap<T>,  pointId: number,  imageId: number,) {  const point = getPointOrThrow(state, pointId);  if (!(imageId in point.linkedImages))    throw Error('No existing image with given ID');  const image = point.linkedImages[imageId];  return {point, image};}export function removeLinkedPointCommon<  T extends ImagesLinkedPoint<P>,  P extends PointOnImage>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; imageId: number }>) {  const { pointId, imageId } = action.payload;  const { point } = getPointAndImageOrThrow(state, pointId, imageId);  delete point.linkedImages[imageId];}export function setLinkedPointXCommon<  T extends ImagesLinkedPoint<P>,  P extends PointOnImage>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; imageId: number; x: number }>) {  const { pointId, imageId, x } = action.payload;  const { image } = getPointAndImageOrThrow(state, pointId, imageId);  image.x = x;}export function setLinkedPointYCommon<  T extends ImagesLinkedPoint<P>,  P extends PointOnImage>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; imageId: number; y: number }>) {  const { pointId, imageId, y } = action.payload;  const { image } = getPointAndImageOrThrow(state, pointId, imageId);  image.y = y;}export function setXByPointIdCommon<T extends RealPoint>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; x: number }>) {  const { pointId, x} = action.payload;  const point = getPointOrThrow(state, pointId);  point.x = x;}export function setYByPointIdCommon<T extends RealPoint>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; y: number }>) {  const { pointId, y} = action.payload;  const point = getPointOrThrow(state, pointId);  point.y = y;}export function setZByPointIdCommon<T extends RealPoint>(  state: PointMap<T>,  action: PayloadAction<{ pointId: number; z: number }>) {  const { pointId, z} = action.payload;  const point = getPointOrThrow(state, pointId);  point.z = z;}export function addCameraPositionCommon(  state: CameraPosition[],  action: PayloadAction<CameraPosition>) {  if (state.map((x) => x.imageId).includes(action.payload.imageId))    throw Error('Image ID must be unique');  state.push(action.payload);}export function removeCameraPositionCommon(  state: CameraPosition[],  action: PayloadAction<number>) {  state.splice(    state.findIndex((x) => x.imageId === action.payload),    1  );}