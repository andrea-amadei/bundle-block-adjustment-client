import "./OptionParams.scss";import React, { useEffect, useState } from "react";interface ComputationParamTemplateBase {  opt: string;  name: string;  type: "DIR_PATH" | "INT" | "DECIMAL" | "ENUM" | "BOOL";  default: string | number | boolean | null;  description?: string;}type ComputationParamTemplateEnum = {  type: "ENUM",  enumValues: string[];} & ComputationParamTemplateBase;type ComputationParamTemplateWithAdditionalParams = {  type: "BOOL",  additionalParamsIfEnabled: ( (ComputationParamTemplateBase & {type: "DIR_PATH" | "INT" | "DECIMAL";}) | ComputationParamTemplateEnum)[]} & ComputationParamTemplateBase;type ComputationParamTemplate =  (ComputationParamTemplateBase & {type: "DIR_PATH" | "INT" | "DECIMAL";}) |  ComputationParamTemplateEnum |  ComputationParamTemplateWithAdditionalParams;interface ComputationParams {  [opt: string]: string | number | null;}const templateParams: ComputationParamTemplate[] = [  // {  //   opt: "out",  //   name: "output directory",  //   type: "DIR_PATH",  //   description: "directory for produced output",  //   default: null,  // },  {    opt: "max",    name: "max iterations",    type: "INT",    description: "max iterations for iterative algorithms",    default: 200  },  {    opt: "pr",    name: "precision",    type: "INT",    description: "decimal precision (number of significant decimal digits)",    default: 10  },  {    opt: "solveIO",    name: "should solve internal orientation",    type: "BOOL",    description: "considers internal orientation parameters as unknowns (pseudo-observation equations are added to the system)",    default: true,    additionalParamsIfEnabled: [      {        opt: "pow",        name: "pseudo observations weight",        type: "DECIMAL",        description: "sets the weight for pseudo-observation equations (only applies if solveIO is selected)",        default: 1      }    ]  },  {    opt: "cw",    name: "constraints weight",    type: "DECIMAL",    description: "sets the weight for constraint equations",    default: 1  },  {    opt: "opt",    name: "optimized",    type: "BOOL",    description: "optimize bundle block adjustment by reducing number of considered tie points and solving remaining tie points separately",    default: true,    additionalParamsIfEnabled: [      {        opt: "block",        name: "max tie points block",        type: "INT",        description: "max block size for tie points (only applies if optimized is selected)",        default: 100      },    ]  },  {    opt: "tpd",    name: "tie points detection",    type: "BOOL",    description: "uses OpenCV library to detect tie points through features matching",    default: false,    additionalParamsIfEnabled: [      {        opt: "nf",        name: "number of features",        type: "INT",        description: "maximum number of features to detect in features detection (only applies if tpd is selected)",        default: 1000      },      {        opt: "scale",        name: "scale factor",        type: "DECIMAL",        description: "scale factor for resizing in features detection (only applies if tpd is selected)",        default: 10      },      {        opt: "ratio",        name: "ratio threshold",        type: "DECIMAL",        description: "ratio threshold for filtering in features matching (only applies if tpd is selected)",        default: 1000      },    ]  },  {    opt: "d",    name: "distortion",    enumValues: ["BROWN", "NONE"],    type: "ENUM",    description: "distortion model to use",    default: "NONE"  },  {    opt: "ic",    name: "input convention",    enumValues: ["YPR", "OPK"],    type: "ENUM",    description: "input angles convention",    default: "YPR"  },  {    opt: "oc",    name: "output convention",    enumValues: ["YPR", "OPK"],    type: "ENUM",    description: "output angles convention",    default: "OPK"  },  {    opt: "iu",    name: "input unit",    enumValues: ["DEG", "RAD"],    type: "ENUM",    description: "input angles unit",    default: "DEG"  },  {    opt: "ou",    name: "output unit",    enumValues: ["DEG", "RAD"],    type: "ENUM",    description: "output angles unit",    default: "RAD"  }]interface PropType {  params: ComputationParams;  setParams: ( updateParams: (oldParams: ComputationParams) => ComputationParams ) => void;}export const ComputationParams: React.FC<PropType> = ({params, setParams}) => {  function getInputFieldType(templateParam: ComputationParamTemplate) {    switch (templateParam.type) {      case "BOOL":        return "checkbox";      case "INT":      case "DECIMAL":        return "number";      default:        throw Error("Param type not supported");    }  }  function getParamValue(templateParam: ComputationParamTemplate) {    return params[templateParam.opt];  }  function setParamValue(templateParam: ComputationParamTemplate, value: any) {    let finalVal = value;    if (templateParam.type === "INT" || templateParam.type === "DECIMAL") {      if (Number.isNaN(finalVal)) {        if (templateParam.type === "INT")          finalVal = parseInt(finalVal, 10);        else          finalVal = parseFloat(finalVal);      } else {        finalVal = Math.round(finalVal);      }      if (Number.isNaN(finalVal))        return;    } else if (templateParam.type === "BOOL") {      finalVal = finalVal && true;    }    setParams(oldParams => ({...oldParams, [templateParam.opt]: finalVal}));  }  function getInputFieldForParam(templateParam: ComputationParamTemplate) {        const label = <div className="param-name">{templateParam.name}</div>;        let description = <></>;    if(templateParam.description)      description = <div className="param-description">{templateParam.description}</div>;    let inputField;    switch (templateParam.type) {      case "BOOL":        inputField = (          <input            checked={getParamValue(templateParam)}            type="checkbox"            onChange={() =>  setParamValue(templateParam, !getParamValue(templateParam))}          />        );        break;      case "INT":      case "DECIMAL":        inputField = (          <input            value={getParamValue(templateParam)}            type="number"            onChange={e =>  setParamValue(templateParam, e.target.value)}          />        );        break;      default:        inputField = <>not yet supported!</>;    }    return (      <div className={`param ${templateParam.type}`} key={templateParam.name}>        {label}        {description}        {inputField}      </div>    );      }  useEffect(() => templateParams.forEach(tp => {    setParamValue(tp, tp.default);    if (tp.type === "BOOL" && "additionalParamsIfEnabled" in tp) {      tp.additionalParamsIfEnabled        .forEach(nestedTp => setParamValue(nestedTp, nestedTp.default));    }  }), []);  return (    <div className="computation-params">      {templateParams.map(tp => {        const showNestedChild = tp.type === "BOOL" && getParamValue(tp) && tp.additionalParamsIfEnabled.length > 0;        return (          <div className="param-block" key={tp.name}>            {getInputFieldForParam(tp)}            {showNestedChild &&              <div className="nested-params">                {tp.additionalParamsIfEnabled.map(nestedTp => getInputFieldForParam(nestedTp))}              </div>            }          </div>        );      })}    </div>);}